COMPOSITE PllLockTime
{
    PllLockTime_Verify(COMPNAME = PllLockTime_Verify)
    0?NEXT,
    1?NEXT;
    
    PllLockTime_Execute(COMPNAME = PllLockTime_Execute)
    0?NEXT,
    1?NEXT;
}

# FAILBIN and TESTINDEX are ignored by Avator

COMPOSITE PllLockTime_Verify
{
    PllLockTime_Verify_Passing(COMPNAME = PllLockTime_Verify_Passing)
    0?NEXT,
    1?NEXT;
    
    PllLockTime_Verify_Bypass(COMPNAME = PllLockTime_Verify_Bypass)
    0?NEXT,
    1?NEXT;
    
    PllLockTime_Verify_Missing(COMPNAME = PllLockTime_Verify_Missing)
    0?NEXT,
    1?NEXT;
    
    PllLockTime_Verify_Invalid(COMPNAME = PllLockTime_Verify_Invalid)
    0?NEXT,
    1?NEXT;

    PllLockTime_Verify_Fewer(COMPNAME = PllLockTime_Verify_Fewer)
    0?NEXT,
    1?NEXT;

    PllLockTime_Verify_FailSpecial(COMPNAME = PllLockTime_Verify_FailSpecial)
    0?NEXT,
    1?NEXT;
}

COMPOSITE PllLockTime_Execute
{
    PllLockTime_Execute_Failing(COMPNAME = PllLockTime_Execute_Failing)
    0?NEXT,
    1?NEXT;
    
    PllLockTime_Execute_Passing(COMPNAME = PllLockTime_Execute_Passing)
    0?NOCONNECT,
    1?NOCONNECT;
    
  # It is important that we do a NOCONNECT for the above composite, as the next
  # composite will be take a lot of test time.

    PllLockTime_Execute_NoConnects(COMPNAME = PllLockTime_Execute_NoConnects)
    0?NEXT,
    1?NEXT;
}


COMPOSITE PllLockTime_Verify_Passing
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_list_pass,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P001 P020, P011",
           ituffName = "PllLockTime_Verify_common",
           ituffPinNames = "P1, P20 P11",
           numRelocks = 2,
           startupOffsets = "25 45, 12",
           killLimits = "2000 1234 981",
           lockIndicator = "L H H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "Passing", 
            TESTDESC = "", 
            DESIREDOUT = "P1");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

# FAILBIN and TESTINDEX are ignored by Avator

	# These test cases will not be verified by iVal post-instance UF until HSD c4693 is fixed.
	   tt_plllocktime_special(
   	            TESTDESC = Bypassed,
   	            bypassGlobal = "Bypass_PllLockTime_Port1",
   	            DESIREDOUT = "P1" ,
   	            debugMode = BRIEF,
   	            preinstance = "",
		   )
   	   1?NEXT,
   	   0?NEXT;

	   tt_plllocktime_special(
   	            TESTDESC = Bypassed,
   	            bypassGlobal = "Bypass_PllLockTime_Port2",
   	            DESIREDOUT = "P2" , # Port 2 is a fail port, but when bypassed it does not matter.
   	            debugMode = BRIEF,
   	            preinstance = "",
		   )
   	   1?NEXT,
   	   0?NEXT;
}

COMPOSITE PllLockTime_Verify_Bypass
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_PllLockTime_1_plist,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P020 P012",
           ituffName = "PllLockTime_Execute_Passing",
           ituffPinNames = "P20 P12",
           numRelocks = 2,
           startupOffsets = "0 0",
           killLimits = "250 250",
           lockIndicator = "L H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "Passing", 
            TESTDESC = Bypass, 
            DESIREDOUT = "P1");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);


    Gen_Bypass_Test ( COMPNAME = GEN_BYPASS_TEST,
                      BypassInstName = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT,
                      BypassVarName = "SEDCBPG1",
                      ExpectedPort = "P1",  
                      NewBypassVal = "2",
                      TESTDESC = Bypass,
                      DESIREDOUT = "P2"
                    )
                     0?NEXT,
                     1?NEXT;

    ######################################################################################################
    # Test Flow: PllLockTime_Verify_Passing_Bypass_P2
    # Test Description: This instance is bypassed to port 2.
    # 		This is a basic passing set.
    # Expected Behavior: Exit on port 2 - bypassed
    ######################################################################################################
    tt_plllocktime_special (
   	TESTDESC = Bypass,
   	DESIREDOUT = "P2" , # Port 2 is a fail port, but when bypassed it does not matter.
        bypassGlobal = SEDCBPG1,
        preinstance = ""
    )
    0?NEXT,
    1?NEXT,
    2?NEXT;
}

COMPOSITE PllLockTime_Verify_Missing
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_list_pass,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P001 P020, P011",
           ituffName = "PllLockTime_Verify_common",
           ituffPinNames = "P1, P20 P11",
           numRelocks = 2,
           startupOffsets = "25 45, 12",
           killLimits = "2000 1234 981",
           lockIndicator = "L H H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "Missing", 
            TESTDESC = "", 
            DESIREDOUT = "F0");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

   
   	   tt_plllocktime (
   	            TESTDESC = patlist,
                    patlist = "",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC = timings,
                    timings = "",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC = level,
                    level = "",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC =  inputPins,
                    inputPins = "",
		   )
   	   1?NEXT,
   	   0?NEXT;


   	   tt_plllocktime (
   	            TESTDESC =  ituffPinNames,
                    ituffPinNames = "",
		   )
   	   1?NEXT,
   	   0?NEXT;


   	   tt_plllocktime (
   	            TESTDESC =  killLimits,
                    killLimits = "",
		   )
   	   1?NEXT,
   	   0?NEXT;
}

COMPOSITE PllLockTime_Verify_Invalid
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_list_pass,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P001 P020, P011",
           ituffName = "PllLockTime_Verify_common",
           ituffPinNames = "P1, P20 P11",
           numRelocks = 2,
           startupOffsets = "25 45, 12",
           killLimits = "2000 1234 981",
           lockIndicator = "L H H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "Invalid", 
            TESTDESC = "", 
            DESIREDOUT = "F0");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

   
   	   tt_plllocktime (
   	            TESTDESC = patlist,
                    patlist = "invalid_patlist",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC = timings,
                    timings = "invalid_timings",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC = level,
                    level = "invalid_level",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC =  inputPins,
                    inputPins = "invalid_pin1 invalid_pin2  invalid_pin3",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	 #  tt_plllocktime (
   	 #           TESTDESC =  nonint_numRelocks,
         #           numRelocks = "invalid_int1",
         #          )
   	 #  1?NEXT,
   	 #  0?NEXT;
   
   	   tt_plllocktime (
   	            TESTDESC =  numRelocks,
                    numRelocks = 0,
		   )
   	   1?NEXT,
   	   0?NEXT;

   # For all the following tests, there are as many valid inputs as the number of input_pins so that there is error just because of this.
   	   tt_plllocktime (
   	            TESTDESC =  startupOffsets,
                    startupOffsets = "0  invalid_offset1  0  0",
		   )
   	   1?NEXT,
   	   0?NEXT;

   	   tt_plllocktime (
   	            TESTDESC =  killLimits,
                    killLimits = "invalid_int1 100 100  100",
		   )
   	   1?NEXT,
   	   0?NEXT;
   
   	   tt_plllocktime (
   	            TESTDESC =  lockIndicator,
                    lockIndicator = "H   l   h  not_H_or_L",
		   )
   	   1?NEXT,
   	   0?NEXT;
}


COMPOSITE PllLockTime_Verify_Fewer
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_list_pass,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P001 P020, P011",
           ituffName = "PllLockTime_Verify_common",
           ituffPinNames = "P1, P20 P11",
           numRelocks = 2,
           startupOffsets = "25 45, 12",
           killLimits = "2000 1234 981",
           lockIndicator = "L H H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "Fewer", 
            TESTDESC = "", 
            DESIREDOUT = "F0");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

   
   	   tt_plllocktime (
   	            TESTDESC = ituffPinNames,
                    ituffPinNames = "P1 P2",
		   )
   	   1?NEXT,
   	   0?NEXT;
   
   	   tt_plllocktime (
   	            TESTDESC = startupOffsets,
                    startupOffsets = "2000",
		   )
   	   1?NEXT,
   	   0?NEXT;
   
   	   tt_plllocktime (
   	            TESTDESC = killLimits,
                    killLimits = "2000 1234",
		   )
   	   1?NEXT,
   	   0?NEXT;
   
   	   tt_plllocktime (
   	            TESTDESC = lockIndicator,
                    lockIndicator = "l",
		   )
   	   1?NEXT,
   	   0?NEXT;
   
    # An exception to this composite: greater values.
#   	   tt_plllocktime (TESTMODE = "Greater", 
#   	            TESTDESC = numCyclesForStableLock,
#                    numCyclesForStableLock = "2112 1235 1234 1253",
#		   )
#   	   1?NEXT,
#   	   0?NEXT;
}


COMPOSITE PllLockTime_Verify_FailSpecial
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_list_pass,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P001",
           ituffName = "PllLockTime_Verify_FailSpecial",
           ituffPinNames = "P1",
           numRelocks = 2,
           startupOffsets = "25",
           killLimits = "2000",
           lockIndicator = "L",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Verify, 
            TESTMODE = "FailSpecial", 
            TESTDESC = "", 
            DESIREDOUT = "F0");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

   
    ######################################################################################################
    # Test Name: PllLockTime_Verify_FailSpecial_KillLimitsBeingZero_F0
    # Test Description: The parameter kill_limits can not be zero.  
    # Expected Behavior: Exit on port 0
    ######################################################################################################
   	   tt_plllocktime (
   	            TESTDESC = KillLimitsBeingZero,
   	            # Intentionally specify two inputs, one good input and other wrong so that the error message of number of kill_limits not being equal to Pll pins is avoided.
   	            killLimits = "0 1",
		   )
   	   1?NEXT,
   	   0?NEXT;

    ######################################################################################################
    # Test Name: PllLockTime_Verify_FailSpecial_DuplicateInputPins_F0
    # Test Description: The parameter input_pins should not have duplicate pin names (if this error check in
    #		code is not done, then there will be double the capture data). To avoid other errors, all inputs
    #		corresponding to the duplicate pin are also specified 
    # Expected Behavior: Exit on port 0
    ######################################################################################################
   	   tt_plllocktime (
   	            TESTDESC = DuplicateInputPins,
   	            inputPins = "P002 P002",
	           ituffPinNames = "P1 P2",
	           numRelocks = 2,
	           startupOffsets = "25 50",
	           killLimits = "2000 2100",
	           lockIndicator = "L H",
		   )
   	   1?NEXT,
   	   0?NEXT;

    ######################################################################################################
    # Test Name: PllLockTime_Verify_FailSpecial_DuplicateItuffPinNames_F0
    # Test Description: The parameter ituff_pin_names should not have duplicate pin names (if this error check in
    #		code is not done, then there will be duplicate iTuff testnames created). To avoid other errors, all inputs
    #		corresponding to the duplicate ituff_pin_names are also specified 
    # Expected Behavior: Exit on port 0
    ######################################################################################################
   	   tt_plllocktime (
   	            TESTDESC = DuplicateItuffPinNames,
   	            inputPins = "P002 P004",
	           ituffPinNames = "P1 P1",
	           numRelocks = 2,
	           startupOffsets = "25 50",
	           killLimits = "2000 2100",
	           lockIndicator = "L H",
		   )
   	   1?NEXT,
   	   0?NEXT;
}


COMPOSITE PllLockTime_Execute_Failing
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_PllLockTime_1_plist,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P020",
           ituffName = "PllLockTime_Execute_Failing",
           ituffPinNames = "P20",
           numRelocks = 1,
           startupOffsets = "0",
           killLimits = "450",
           lockIndicator = "L",
           debugMode = VERBOSE);

      # The above is a set of passing conditions.
      
       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Execute, 
            TESTMODE = "", 
            TESTDESC = "", 
            DESIREDOUT = "");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

    ######################################################################################################
    # Test Name: PllLockTime_Execute_NoCTVs_InPList_F0
    # Test Description: The PList: basic_func_list_pass has no pattern with CTV in it.
    #			Fails to read DMEM
    # Expected Behavior: Exit on port 0
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = NoCTVs,
   	            TESTDESC = InPList,
   	            DESIREDOUT = F0,
   	            patlist = basic_func_list_pass,
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
# Future Work: Check whether this test case is valid
    
    ######################################################################################################
    # Test Name: PllLockTime_Execute_NoCTVs_ForPin_F0
    # Test Description: The Pin: P033 is not defined for this Pattern.
    #			Fails to read DMEM
    # Expected Behavior: Exit on port 0
    ######################################################################################################
# This test crashes the system at m_tExecPlist call.
#  	   tt_plllocktime (TESTMODE = NoCTVs,
#   	            TESTDESC = ForPin,
#   	            DESIREDOUT = F0,
#   	            inputPins = "P033",
#   	            ituffPinNames = "P33",
#   	            )
#   	   1?NEXT,
#   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_NoDataToAnalyze_ForPin_F0
    # Test Description: Just to make a piece of code hit, increase the number of relocks so that there is 
    #			no data to analyze for all relocks, except last (however fails for first relock).
    #			Total captured data: 606 cycles.  So, number of relocks made 607.
    # Expected Behavior: Exit on port 0
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = NoDataToAnalyze,
   	            TESTDESC = ForPin,
   	            DESIREDOUT = F0,
   	            numRelocks = 607,
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_OnePin_Xs_in_Vectors_F2
    # Test Description: This Pin P002 has only Xs in all the vectors that have CTVs.  
    #			DMEM reads out everything as 0s
    # Expected Behavior: Exit on port 2
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = OnePin,
   	            TESTDESC = Xs_in_Vectors,
   	            DESIREDOUT = F2,
   	            inputPins = "P002",
   	            ituffPinNames = "P2",
	            lockIndicator = "H",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_OnePin_Hs_in_Vectors_F2
    # Test Description: This Pin P004 has only Hs in all the vectors that have CTVs.  
    #			DMEM reads out everything as 0s
    # Expected Behavior: Exit on port 2
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = OnePin,
   	            TESTDESC = Hs_in_Vectors,
   	            DESIREDOUT = F2,
   	            inputPins = "P004",
   	            ituffPinNames = "P4",
	            lockIndicator = "H",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_OnePin_InputPin_F2
    # Test Description: This Pin P001 is an input pin
    #			DMEM reads out everything as 0s
    # Expected Behavior: Exit on port 2
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = OnePin,
   	            TESTDESC = InputPin,
   	            DESIREDOUT = F2,
   	            inputPins = "P001",
   	            ituffPinNames = "P1",
	            lockIndicator = "H",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_OnePin_FirstCycleFail_F2
    # Test Description: This Pin P010 fails because the first cycle itself is locked (lock_indicator = L).
    # Expected Behavior: Exit on port 2
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = OnePin,
   	            TESTDESC = FirstCycleFail,
   	            DESIREDOUT = F2,
   	            inputPins = "P010",
   	            ituffPinNames = "P10",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_SecondPinFail_FailKillLimit_F3
    # Test Description: Second PLL Pin: P018 does not satisfy the num_cycles_for_stable_lock limit
    #			First PLL Pin: P020 will pass, while P018 will find lock after 405 cycles (Kill_Limit is set to 404).  Setting kill_limit to 405 and more will pass.
    # Expected Behavior: Exit on port 3
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = SecondPinFail,
   	            TESTDESC = FailKillLimit,
   	            DESIREDOUT = F3,
	           inputPins = "P020 P018",
	           ituffPinNames = "P20 P18",
	           numRelocks = 1,
	           startupOffsets = "0 0",
	           killLimits = "450 404",
	           lockIndicator = "L L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_SecondPinFail_1stRelock_FailKillLimit_F3
    # Test Description: Second PLL Pin's 1st Relock: P014 does not satisfy the kill_limit
    #			First PLL Pin: P020 will pass, while P014's 1st relock will have it's last lock after 102 cycles (kill_limit is 101).
    # Expected Behavior: Exit on port 3
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = SecondPinFail,
   	            TESTDESC = 1stRelock_FailKillLimit,
   	            DESIREDOUT = F3,
	           inputPins = "P020 P014",
	           ituffPinNames = "P20 P14",
	           numRelocks = 2,
	           startupOffsets = "0 0",
	           killLimits = "250 101",
	           lockIndicator = "L L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_SecondPinFail_LostLock_F3
    # Test Description: Second PLL Pin: P016 loses its lock after a lock
    #			First PLL Pin: P020 will pass, while P016 will lose lock before the capturing ends.
    # Expected Behavior: Exit on port 3
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = SecondPinFail,
   	            TESTDESC = LostLock,
   	            DESIREDOUT = F3,
	           inputPins = "P020 P016",
	           ituffPinNames = "P20 P16",
	           numRelocks = 1,
	           startupOffsets = "0 0",
	           killLimits = "450 450",
	           lockIndicator = "L L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_MultipleRelocks_InsufficientStartupOffset_F2
    # Test Description: Selected Multiple Relocks (4) and each of them not being same
    #			Total Captured: 606 cycles: so, 151 cycles for first 3 relocks and 153 for last relock
    #			Selected 151 for the startup_offsets.  So, will fail first 3 relocks
    #			DMEM reads out everything as 0s
    # Expected Behavior: Exit on port 2
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = MultipleRelocks,
   	            TESTDESC = InsufficientStartupOffset,
   	            DESIREDOUT = F2,
	           inputPins = "P020",
	           ituffPinNames = "P20",
	           numRelocks = 4,
	           startupOffsets = "151",
	           killLimits = "450",
	           lockIndicator = "L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_ThirdPinFail_LostLock_F4
    # Test Description: This test is same as PllLockTime_Execute_SecondPinFail_LostLock_F3 only that another 
    #		passing case (pin P012) has been added (earlier had 2 pins as P020, which would now cause an error).
    #		Introduced this test to exit to Port 4
    #		Third PLL Pin: P016 loses its lock after a lock
    #		First 2 PLL Pins are the same and is P020
    # Expected Behavior: Exit on port 4
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = ThirdPinFail,
   	            TESTDESC = LostLock,
   	            DESIREDOUT = F4,
	           inputPins = "P020 P012 P016",
	           ituffPinNames = "P20 P12 P16",
	           numRelocks = 1,
	           startupOffsets = "0 0 0",
	           # Need to bump up kill_limits to make it pass because of HSD c4288
	           killLimits = "1100 400 250",
	           lockIndicator = "L H L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_FourthPinFail_LostLock_F5
    # Test Description: This test is same as PllLockTime_Execute_SecondPinFail_LostLock_F3 only that more
    #		passing cases (pin P012, P018) are added in between. (earlier had P020 used thrice)
    #		Introduced this test to exit to Port 5
    #		Fourth PLL Pin: P016 loses its lock after a lock
    # Expected Behavior: Exit on port 5
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = FourthPinFail,
   	            TESTDESC = LostLock,
   	            DESIREDOUT = F5,
	           inputPins = "P020 P012 P018 P016",
	           ituffPinNames = "P20 P12 P18 P16",
	           numRelocks = 1,
	           startupOffsets = "0 0 0 0",
	           killLimits = "1800 400 500 250",
	           lockIndicator = "L H L L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_FifthPinFail_LostLock_F6
    # Test Description: This test is same as PllLockTime_Execute_SecondPinFail_LostLock_F3 only that more
    #		passing cases (pins P012, P018, P014, P016) are added in between (earlier had P020 used four times)
    #		Introduced this test to exit to Port 6
    #		Fifth PLL Pin: P016 loses its lock after a lock
    # Expected Behavior: Exit on port 6
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = FifthPinFail,
   	            TESTDESC = LostLock,
   	            DESIREDOUT = F6,
	           inputPins = "P020 P012 P018 P014 P016",
	           ituffPinNames = "P20 P12 P18 P14 P16",
	           numRelocks = 1,
	           startupOffsets = "0 0 0 0 0",
	           killLimits = "2400 400 500 2400 250",
	           lockIndicator = "L H L L L",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_TwoDomains_SecondPinFail_F3
    # Test Description: These Pin P020, P034 are passing pins when strobing for L and H respectively.  But 
    #			to make the Second Pin (P034) fail, strobe character is specified as L.
    # Expected Behavior: Exit on port 3
    ######################################################################################################

  	   tt_plllocktime (TESTMODE = TwoDomains,
   	            TESTDESC = SecondPinFail,
   	            DESIREDOUT = F3,
   	            patlist = mtd_250MDM_PllLockTime_1_plist,
   	            timings = mtd_timings_TC,
   	            level = mtd_level_TC,
   	            inputPins = "P020 P034",
   	            ituffPinNames = "P20, P34",
   	            numRelocks = 1,
   	            lockIndicator = "L L",
   	            killLimits = "450 450",
   	            startupOffsets = "0 0",
   	            debugMode = BRIEF,
  		   )
   	   1?NEXT,
   	   0?NEXT;
  	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Fail_NoCaptureData_BcozOf_SelectivePXR_F0
    # Test Description: This test runs a pattern with both HS and LS domains, but the PXR file that the
    #		pattern references has TSModeSelect{CTV;MTV;} in VendorSection, but not in CommonSection,
    #		which causes no pattern data to be captured
    # Expected Behavior: Exit on port 0
    ######################################################################################################
# This test case was created after Lyne P complained about not getting any capture data.
# But this test case did not result in a failure, so commented it out.
#  	   tt_plllocktime (TESTMODE = Fail,
#   	            TESTDESC = NoCaptureData_BcozOf_SelectivePXR,
#   	            DESIREDOUT = F0,
#    		    patlist = Func_65GDM_DS_8X_ClkTrack_250DM_DDR_BasicPass_TSMode_Selective_PllLockTime_list,
#           	    timings = Timing_65GDM_DS_8X_LSV_ClkTrack_250DM_DDR_TC_slow,
#           	    level = iVal65BasicLevelNom,
#	            inputPins = "P002",
#	            ituffPinNames = "P02",
#	            numRelocks = 1,
#	            #  startupOffsets = "0", # This is default
#	            killLimits = "40",
#	            lockIndicator = "L",
#   	            )
#   	   1?NEXT,
#   	   0?NEXT;
   	   
}


COMPOSITE PllLockTime_Execute_Passing
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_PllLockTime_1_plist,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P020 P012",
           ituffName = "PllLockTime_Execute_Passing",
           ituffPinNames = "P20 P12",
           numRelocks = 2,
           startupOffsets = "0 0",
           killLimits = "250 250",
           lockIndicator = "L H",
           debugMode = VERBOSE);

       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Execute, 
            TESTMODE = "", 
            TESTDESC = "", 
            DESIREDOUT = "");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_KillLimitGreaterThanCapturedCycles_P1
    # Test Description: This Pin P020 is a passing pin for both relocks (each relock has 303 (num_relocks=2, startup_offset=0))
    #			But the kill_limit set to 304, which triggers the warning message that it has no effect
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = KillLimitGreaterThanCapturedCycles,
   	            DESIREDOUT = P1,
	            killLimits = "304 304",
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_TwoDomains_P1
    # Test Description: These Pins P020, P034 are passing pins when strobing for L and H respectively
    #		P020 whic is on the domain "default" has 303 cycles CTV'ed
    #		P034 which is on Second_domain has 103 cycles CTV'ed (since kill_limit for this is 200, generates a warning)
    #		(this test instance takes a little bit of time to complete: ~10sec).
    # Expected Behavior: Exit on port 1
    ######################################################################################################

  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = TwoDomains,
   	            DESIREDOUT = P1,
   	            patlist = mtd_250MDM_PllLockTime_1_plist,
   	            timings = mtd_timings_TC,
   	            level = mtd_level_TC,
   	            inputPins = "P020 P034",
   	            ituffPinNames = "P20, P34",
   	            killLimits = "200 200",
   	            numRelocks = 1,
   	            lockIndicator = "L H",
   	            debugMode = BRIEF,
  		   )
   	   1?NEXT,
   	   0?NEXT;
  	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_Debug_Disabled_P1
    # Test Description: These Pin P020, P012 are passing pins when strobing for L and H respectively
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = Debug_Disabled,
   	            debugMode = DISABLED,
   	            DESIREDOUT = P1,
		   )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_Debug_Brief_P1
    # Test Description: These Pin P020, P012 are passing pins when strobing for L and H respectively
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = Debug_Brief,
   	            debugMode = BRIEF,
   	            DESIREDOUT = P1,
		   )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_Debug_Verbose_P1
    # Test Description: These Pin P020, P012 are passing pins when strobing for L and H respectively
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = Debug_Verbose,
   	            debugMode = VERBOSE,
   	            DESIREDOUT = P1,
		   )
   	   1?NEXT,
   	   0?NEXT;
   	   
    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_Debug_Obnoxious_P1
    # Test Description: These Pin P020, P012 are passing pins when strobing for L and H respectively
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = Passing,
   	            TESTDESC = Debug_Obnoxious,
   	            debugMode = OBNOXIOUS,
   	            DESIREDOUT = P1,
		   )
   	   1?NEXT,
   	   0?NEXT;

    ######################################################################################################
    # Test Name: PllLockTime_Execute_Passing_AltInstanceNameSet_P1
    # Test Description: These Pin P020, P012 are passing pins when strobing for L and H respectively
    #		Calls a preinstance UF to set the m_sAltInstanceName (this takes precedence over ituff_name 
    #		and test instance name)
    # Expected Behavior: Exit on port 1
    ######################################################################################################
  	   tt_plllocktime_special (TESTMODE = Passing,
   	            TESTDESC = AltInstanceNameSet,
   	            ituffName = "Tname_of_no_significance",
   	            preinstance = "iVal_utilityfunc!ChangeAltInstanceName PllLockTime_NewInstanceName"
   	            bypassGlobal = "",  # Uncommented for this tt_ in the convention_PllLockTime.pln file
   	            debugMode = VERBOSE,
   	            DESIREDOUT = P1,
		   )
   	   1?NEXT,
   	   0?NEXT;
   	   

}


COMPOSITE PllLockTime_Execute_NoConnects
{
      DEF (SEGNAME = $name,
           postinstance = "iVal_utilityfunc!GenerateInstanceResults",
           patlist = basic_func_PllLockTime_1_plist,
           timings = iValTimings50MHz,
           level = iValLevelFuncPass,
           inputPins = "P020",
           ituffName = "PllLockTime_Execute_Failing",
           ituffPinNames = "P20",
           numRelocks = 1,
           startupOffsets = "0",
           killLimits = "450",
           lockIndicator = "L",
           debugMode = VERBOSE);

      # The above is a set of passing conditions.
      
       DEF (TEMPLATENAME = PllLockTime, 
            TESTTYPE = Execute, 
            TESTMODE = "", 
            TESTDESC = "", 
            DESIREDOUT = "");
       DEF (INSTANCENAME = $TEMPLATENAME_$TESTTYPE_$TESTMODE_$TESTDESC_$DESIREDOUT);
       DEF (name = $INSTANCENAME, BINNAME = $INSTANCENAME);

    ######################################################################################################
    # Test Name: PllLockTime_Execute_MoreThan4MegCTVs_Fail_F0
    # Test Description: The hard-coded limit to captured cycles is 4Meg, if there are more than that
    #			the code prints a warning message that only the last 4Meg cycles are analyzed.
    #			The Pattern is built such a way that if we lose the 1st cycle of CTV, then it will fail.
    # Expected Behavior: Exit on port 0
    ######################################################################################################
  	   tt_plllocktime (TESTMODE = MoreThan4MegCTVs,
   	            TESTDESC = Fail,
   	            DESIREDOUT = F0,
   	            patlist = basic_func_MoreThan4MegCTVs_PllLockTime_1_plist,
   	            )
   	   1?NEXT,
   	   0?NEXT;
   	   
}
